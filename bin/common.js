const {terminal: term} = require("terminal-kit");
const {readFile} = require("fs/promises");
const {resolve} = require("node:path");

/**
 * read content of a file on file system
 * @param pathToFile path to package.json
 * @returns {Promise<*>} content of json file
 */
exports.readPackageJson = async pathToFile => {
    try {
        const filePath = resolve(pathToFile);
        return await readFile(filePath, {encoding: "utf8"});
    } catch (err) {
        term.red(err.message);
        process.exit();
    }
};


/**
 * returns package.json dependency and dev-dependency in a single object
 * @param fileContent
 * @returns {Promise<void>} combined dependencies of dev and main packages
 */
exports.getAllDependencies = fileContent => {
    const jsonFileContent = JSON.parse(fileContent);
    let combinedDep = {};

    if (jsonFileContent.dependencies) {
        combinedDep = jsonFileContent.dependencies;
    }
    if (jsonFileContent.devDependencies) {
        combinedDep = {...combinedDep, ...jsonFileContent.devDependencies};
    }
    return combinedDep;
};


/**
 * prints vulnerability response in table format
 * @param listOfVulnerabilities
 */
exports.prettyPrintTable = listOfVulnerabilities => {
    //Create a table
    let index = 1;
    const row = [[
        `No.(Total ${listOfVulnerabilities.length})`,
        `Name`,
        "Id",
        "Description",
        "Severity",
        "Detail link"
    ]];
    for (const vulnerability of listOfVulnerabilities) {
        const rowColor = getColor(vulnerability.cvssScore);
        row.push([
            index++,
            `${rowColor} ${vulnerability.displayName}`,
            vulnerability.id,
            vulnerability.description,
            `${rowColor} ${vulnerability.cvssScore}`,
            vulnerability.reference
        ]);
    }

    term.table(row, {
            hasBorder: true,
            borderChars: 'lightRounded',
            lineWrap: true,
            contentHasMarkup: true,
            fit: true   // Activate all expand/shrink + wordWrap
        }
    );

}

/**
 * prints vulnerability response in compressed json or default json format
 * @param listOfVulnerabilities
 * @param format
 */
exports.prettyPrintJson = (listOfVulnerabilities, format) => {
    let output = {
        vulnerabilities: listOfVulnerabilities
    };
    if (format === 'json') {
        output = JSON.stringify(output);
    }
    console.log(output);
}

/**
 * function to get highlight color for a severity i.e HIGH => RED(^R)
 * @param severityInWord
 * @returns {string} color name
 */
const getColor = exports.getColor = severityInWord => {
    return severityInWord === 'HIGH' ? '^R' : '^Y'
}

/**
 * converts a severity number to word i.e 9 => HIGH
 * @param severityInNumber
 * @returns {string}
 */
exports.severityNumberToWord = severityInNumber => {
    return severityInNumber >= 7 ? 'HIGH' : 'MODERATE';
}


/**
 * returns formatted package version and name i.e (@axios, ^2.1.1) => (axios, 2.1.1)
 * @param dependencyName
 * @param version
 * @returns {{packageName, version}}
 */
exports.getNameAndVersion = (dependencyName, version) => {
    let packageName = dependencyName;

    if (packageName.startsWith("@")) {
        packageName = packageName.slice(1, dependencyName.length);
    }
    if (version.startsWith("^") || version.startsWith("~")) {
        version = version.slice(1);
    }

    return {packageName, version};
}